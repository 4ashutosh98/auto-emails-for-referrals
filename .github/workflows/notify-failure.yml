name: Notify mailer failures

on:
  workflow_run:
    workflows: ["Send referral emails"]
    types: [completed]

permissions:
  contents: read
  issues: write
  actions: read

jobs:
  failure_notify:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    name: Record failure
    runs-on: ubuntu-latest
    steps:
      - name: Gather metadata
        id: meta
        run: |
          echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "run_number=${{ github.event.workflow_run.run_number }}" >> $GITHUB_OUTPUT
          echo "head_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          echo "run_html_url=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT
          echo "event=${{ github.event.workflow_run.event }}" >> $GITHUB_OUTPUT

      - name: Install log unzip dependency
        run: |
          npm init -y >/dev/null 2>&1
            npm install adm-zip@0.5.10 >/dev/null 2>&1

      - name: Fetch log snippet & update failure issue
        uses: actions/github-script@v7
        env:
          RUN_ID: ${{ steps.meta.outputs.run_id }}
          RUN_NUMBER: ${{ steps.meta.outputs.run_number }}
          RUN_SHA: ${{ steps.meta.outputs.head_sha }}
          RUN_URL: ${{ steps.meta.outputs.run_html_url }}
          RUN_EVENT: ${{ steps.meta.outputs.event }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = process.env.RUN_ID;
            const runNumber = process.env.RUN_NUMBER;
            const sha = process.env.RUN_SHA;
            const url = process.env.RUN_URL;
            const event = process.env.RUN_EVENT;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const shortSha = sha.substring(0,7);
            const trackerLabel = 'ci-failure-tracker';
            const baseTitle = 'Mailer workflow failing';

            // Ensure labels
            async function ensureLabel(name, color) {
              try { await github.rest.issues.createLabel({ owner, repo, name, color }); } catch(e) {}
            }
            await ensureLabel(trackerLabel, 'd73a4a');
            await ensureLabel('ci-failure', 'd73a4a');

            // Attempt to download run logs zip
            let firstLines = [], lastLines = [], totalLines = 0;
            try {
              const logsResp = await github.request('GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs', { owner, repo, run_id: runId, responseType: 'arraybuffer' });
              const AdmZip = require('adm-zip');
              const zip = new AdmZip(Buffer.from(logsResp.data));
              // Heuristic: gather all *.txt files, concatenate
              let combined = '';
              zip.getEntries().forEach(e => {
                if (e.entryName.endsWith('.txt')) {
                  combined += zip.readAsText(e) + '\n';
                }
              });
              const lines = combined.split(/\r?\n/).filter(l => l.trim().length);
              totalLines = lines.length;
              firstLines = lines.slice(0, 15);
              lastLines = lines.slice(-25);
            } catch (e) {
              firstLines = ['(log snippet unavailable â€“ could not fetch or unzip logs)'];
            }

            // Find existing open tracker issue
            const existingIssues = await github.rest.issues.listForRepo({ owner, repo, state: 'open', labels: trackerLabel });
            let issueNumber = null;
            let streak = 1;
            if (existingIssues.data.length > 0) {
              const issue = existingIssues.data[0];
              issueNumber = issue.number;
              const m = issue.body && issue.body.match(/Current failure streak: (\d+)/);
              if (m) {
                streak = parseInt(m[1], 10) + 1;
              } else {
                streak = 1;
              }
            }

            const snippet = [
              '```',
              ...firstLines,
              (firstLines.length && lastLines.length ? '... (truncated) ...' : ''),
              ...lastLines,
              '```'
            ].join('\n');

            const bodyBase = `The scheduled *Send referral emails* workflow failed.\n\n` +
              `**Run:** ${url}\n` +
              `**Event:** ${event}\n` +
              `**Commit:** ${sha}\n` +
              `**Current failure streak: ${streak}**\n` +
              `**Log lines (first 15 / last 25, total ${totalLines}):**\n${snippet}\n\n` +
              `This issue auto-updates on each failure and will be closed automatically after a successful run.`;

            if (!issueNumber) {
              const created = await github.rest.issues.create({ owner, repo, title: baseTitle, body: bodyBase, labels: [trackerLabel, 'ci-failure'] });
              core.info(`Created tracker issue #${created.data.number}`);
            } else {
              // Update body with new streak & snippet
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body: bodyBase });
              await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: `Failure run #${runNumber} (${shortSha}) recorded. Run: ${url}` });
              core.info(`Updated tracker issue #${issueNumber}`);
            }

  success_close:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    name: Resolve on success
    runs-on: ubuntu-latest
    steps:
      - name: Close tracker if present
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issues = await github.rest.issues.listForRepo({ owner, repo, state: 'open', labels: 'ci-failure-tracker' });
            if (issues.data.length === 0) {
              return;
            }
            const issue = issues.data[0];
            const runUrl = '${{ github.event.workflow_run.html_url }}';
            await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: `Recovered on successful run: ${runUrl}. Closing issue.` });
            await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });
            core.info(`Closed tracker issue #${issue.number}`);
